from __future__ import annotations

import argparse
import asyncio
import os
from pathlib import Path
from typing import Any

import pandas as pd
from fastmcp import FastMCP

from .client import TushareClient
from .config import resolve_rate_limits
from .specs import SpecStore


def _env_float(name: str, default: float) -> float:
    try:
        return float(os.environ.get(name, "").strip() or default)
    except Exception:
        return default


def _env_int(name: str, default: int) -> int:
    try:
        return int(os.environ.get(name, "").strip() or default)
    except Exception:
        return default


def create_mcp_app(
    *,
    specs_path: str | Path | None,
    max_rows: int = 100,
    min_interval_seconds: float = 0.35,
) -> FastMCP:
    store = SpecStore.load(specs_path)
    client = TushareClient.from_env(min_interval_seconds=min_interval_seconds)

    mcp = FastMCP("tushare-universal-mcp")

    @mcp.tool(
        name="search_api_docs",
        description="Fuzzy-search Tushare API docs from local specs JSON (metadata-driven dictionary).",
    )
    def search_api_docs(keyword: str, limit: int = 10) -> dict[str, Any]:
        if not store.apis:
            return {
                "ok": False,
                "error": "Spec store is empty. Generate `tushare_api_specs.json` with `tushare-mcp-scrape` and pass `--specs`.",
                "meta": store.meta,
            }
        matches = store.search(keyword, limit=limit)
        return {"ok": True, "keyword": keyword, "count": len(matches), "results": matches, "meta": store.meta}

    @mcp.tool(
        name="execute_tushare_query",
        description="Execute any Tushare PRO API by name via reflection (getattr(pro, api_name)(**params)).",
    )
    def execute_tushare_query(api_name: str, params: dict[str, Any] | None = None) -> dict[str, Any]:
        params = params or {}
        spec = store.get(api_name)
        validation = SpecStore.validate_params(spec, params)
        if not validation["ok"]:
            return {
                "ok": False,
                "error": "Missing required params.",
                "api_name": api_name,
                "missing_required": validation["missing_required"],
                "unknown_params": validation["unknown_params"],
                "doc": spec or None,
            }

        try:
            result = client.call(api_name, params)
        except Exception as e:
            message = str(e).strip() or e.__class__.__name__
            hint = None
            if "Missing Tushare token" in message:
                hint = "Set env `TUSHARE_TOKEN` (or `TS_TOKEN`)."
            elif spec:
                hint = "Use `search_api_docs` to confirm correct params, then retry."
            return {
                "ok": False,
                "api_name": api_name,
                "params": params,
                "error": message,
                "hint": hint,
            }

        if isinstance(result, pd.DataFrame):
            total_rows = int(result.shape[0])
            truncated = total_rows > max_rows
            df = result.head(max_rows) if truncated else result
            data = df.where(pd.notnull(df), None).to_dict(orient="records")
            return {
                "ok": True,
                "api_name": api_name,
                "params": params,
                "meta": {
                    "total_rows": total_rows,
                    "returned_rows": len(data),
                    "truncated": truncated,
                    "max_rows": max_rows,
                    "note": f"Total: {total_rows} rows, Truncated to: {max_rows}" if truncated else f"Total: {total_rows} rows",
                    "columns": list(df.columns),
                    "unknown_params": validation["unknown_params"],
                },
                "data": data,
            }

        # Fallback for unexpected result types
        return {
            "ok": True,
            "api_name": api_name,
            "params": params,
            "meta": {"result_type": type(result).__name__, "unknown_params": validation["unknown_params"]},
            "data": result,
        }

    return mcp


async def _run_stdio(specs: str | None, max_rows: int, min_interval_seconds: float) -> None:
    mcp = create_mcp_app(specs_path=specs, max_rows=max_rows, min_interval_seconds=min_interval_seconds)
    await mcp.run_stdio_async()


def cli_main() -> None:
    parser = argparse.ArgumentParser(description="Universal Tushare MCP server (FastMCP, stdio).")
    parser.add_argument(
        "--specs",
        default=os.environ.get("TUSHARE_MCP_SPECS_PATH") or "data/tushare_api_specs.json",
        help="Path to tushare_api_specs.json generated by scraper.",
    )
    parser.add_argument(
        "--points",
        type=int,
        default=None,
        help="Optional Tushare points (used to select rate-limit tier from limits file).",
    )
    parser.add_argument(
        "--limits-path",
        default=os.environ.get("TUSHARE_MCP_LIMITS_PATH") or "config/tushare_rate_limits.json",
        help="JSON file with tiers to map points->limits.",
    )
    parser.add_argument(
        "--max-rows",
        type=int,
        default=None,
        help="Truncate DataFrame results to this many rows.",
    )
    parser.add_argument(
        "--min-interval-seconds",
        type=float,
        default=None,
        help="Simple rate limiting: minimum seconds between Tushare requests.",
    )
    args = parser.parse_args()
    limits = resolve_rate_limits(
        max_rows_env=os.environ.get("TUSHARE_MCP_MAX_ROWS") if args.max_rows is None else str(args.max_rows),
        min_interval_env=os.environ.get("TUSHARE_MCP_MIN_INTERVAL_SECONDS")
        if args.min_interval_seconds is None
        else str(args.min_interval_seconds),
        points_env=os.environ.get("TUSHARE_POINTS") if args.points is None else str(args.points),
        limits_path=args.limits_path,
        default_max_rows=100,
        default_min_interval_seconds=0.35,
    )
    asyncio.run(_run_stdio(args.specs, limits.max_rows, limits.min_interval_seconds))
